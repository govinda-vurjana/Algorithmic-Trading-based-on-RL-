# Trading Strategy Implementation Task

Implement a function that generates trading signals using technical analysis on tick data.

**IMPORTANT INSTRUCTIONS:**
1. Respond ONLY with valid Python code
2. Do not include markdown code blocks (```python```)
3. Do not include any explanations or comments outside the code
4. Your strategy MUST generate at least 5-10 trading signals (not all zeros)
5. Test that `np.sum(np.abs(signals)) > 0` before returning

## Task Overview
You'll create a trading strategy that:
1. Loads tick-level price data from a CSV file
2. Resamples it to 1-minute OHLC (Open, High, Low, Close) bars
3. Calculates at least ONE technical indicator using TA-Lib
4. Generates trading signals based on the indicator(s)
5. Returns signals and performance metrics

## Function Signature
```python
def predict_trade(data_path: str) -> dict:
    """
    Generate trading signals from tick data.
    
    Args:
        data_path: Path to CSV file with columns: 'day', 'timestamp', 'value'
                   The CSV has a header row.
        
    Returns:
        dict: {
            'signals': np.ndarray of ints (-1, 0, 1),  # sell, hold, buy
            'metrics': {
                'cumulative_returns_final': float,  # Total return (e.g., 0.15 = 15%)
                'sharpe_ratio': float,              # Risk-adjusted return
                'max_drawdown': float,              # Max decline from peak (0-1 range)
            }
        }
    """
```

## Requirements

### 1. Data Processing
**CRITICAL: You MUST use this exact data loading code:**
```python
df = pd.read_csv(data_path, names=['day', 'timestamp', 'value'], header=0)
df['timestamp'] = pd.to_datetime(df['timestamp'])
df.set_index('timestamp', inplace=True)
ohlc = df['value'].resample('1min').ohlc().ffill()
```

- Read the CSV file (has header: 'day', 'timestamp', 'value')
- Resample tick data to 1-minute OHLC bars using `'1min'` frequency
- Handle NaN values appropriately (forward fill or drop)
- The dataset is small (~343 rows), so use all data for both training and testing

### 2. Technical Indicators
**You must use at least ONE technical indicator from TA-Lib in your trading logic.**

Common indicators you can use:
- **RSI** (Relative Strength Index): `talib.RSI(close, timeperiod=14)`
- **MACD** (Moving Average Convergence Divergence): `talib.MACD(close, 12, 26, 9)`
- **EMA** (Exponential Moving Average): `talib.EMA(close, timeperiod=20)`
- **Bollinger Bands**: `talib.BBANDS(close, timeperiod=20)`
- **ATR** (Average True Range): `talib.ATR(high, low, close, timeperiod=14)`
- **Stochastic**: `talib.STOCH(high, low, close, 14, 3, 3)`

**Note**: Do NOT use volume-based indicators (like OBV) as the dataset has no volume data.

### 3. Trading Signals
- Generate signals as integers:
  - `1` = Buy signal
  - `-1` = Sell signal
  - `0` = Hold (no action)
- Signals should be based on your indicator(s)
- The signals array must match the length of your resampled data

### 4. Performance Metrics
Calculate these three required metrics:

- **cumulative_returns_final**: Total return of the strategy
  - Calculate as: `(final_portfolio_value / initial_value) - 1`
  - Must be a finite number between -1.0 and 10.0

- **sharpe_ratio**: Risk-adjusted return
  - Calculate as: `mean(returns) / std(returns) * sqrt(252)`
  - Must be a finite number between -5.0 and 10.0
  - Must be at least 2.0 for a passing strategy (excellent risk-adjusted returns)

- **max_drawdown**: Maximum peak-to-trough decline
  - Calculate as: `max((peak - trough) / peak)` for all peaks
  - Must be between 0.0 and 1.0 (e.g., 0.3 = 30% drawdown)
  - Must be less than 0.25 (25%) for a passing strategy

## Example Approach

**CRITICAL: You MUST use this exact data loading pattern:**

```python
import pandas as pd
import numpy as np
import talib

def predict_trade(data_path: str) -> dict:
    # 1. Load and resample data - USE THIS EXACT PATTERN
    df = pd.read_csv(data_path, names=['day', 'timestamp', 'value'], header=0)
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df.set_index('timestamp', inplace=True)
    ohlc = df['value'].resample('1min').ohlc().ffill()
    
    # 2. Calculate indicators
    close = ohlc['close'].values
    
    # Example: Use RSI as primary indicator
    rsi = talib.RSI(close, timeperiod=14)
    
    # Example: Use MACD for confirmation
    macd, macd_signal, _ = talib.MACD(close, 12, 26, 9)
    
    # 3. Generate trading signals - SIMPLE APPROACH
    signals = np.zeros(len(close), dtype=int)
    
    # Start after indicators warm up (avoid NaN values)
    for i in range(26, len(close)):
        # Buy signal: RSI oversold + MACD bullish
        if rsi[i] < 40 and macd[i] > macd_signal[i]:
            signals[i] = 1
        # Sell signal: RSI overbought + MACD bearish
        elif rsi[i] > 60 and macd[i] < macd_signal[i]:
            signals[i] = -1
    
    # 4. Calculate performance metrics
    returns = np.diff(close) / close[:-1]
    strategy_returns = returns * signals[:-1]
    
    # Remove any NaN or inf values
    strategy_returns = strategy_returns[np.isfinite(strategy_returns)]
    
    # Cumulative returns (use sum of log returns to avoid overflow)
    if len(strategy_returns) > 0:
        cumulative_returns = np.expm1(np.sum(np.log1p(strategy_returns)))
    else:
        cumulative_returns = 0.0
    
    # Sharpe ratio (with safety check)
    if len(strategy_returns) > 0:
        mean_ret = np.mean(strategy_returns)
        std_ret = np.std(strategy_returns)
        sharpe = (mean_ret / std_ret * np.sqrt(252)) if std_ret > 0 else 0.0
    else:
        sharpe = 0.0
    
    # Max drawdown
    if len(strategy_returns) > 0:
        cumulative = np.cumprod(1 + strategy_returns)
        running_max = np.maximum.accumulate(cumulative)
        drawdown = (running_max - cumulative) / running_max
        max_dd = np.max(drawdown)
    else:
        max_dd = 0.0
    
    # Ensure all metrics are finite
    if not np.isfinite(cumulative_returns):
        cumulative_returns = 0.0
    if not np.isfinite(sharpe):
        sharpe = 0.0
    if not np.isfinite(max_dd):
        max_dd = 0.0
    
    return {
        'signals': signals,
        'metrics': {
            'cumulative_returns_final': float(cumulative_returns),
            'sharpe_ratio': float(sharpe),
            'max_drawdown': float(max_dd)
        }
    }
```

## Grading Criteria
Your solution will pass if:
1. ✅ Function `predict_trade` exists and takes one parameter
2. ✅ At least one TA-Lib indicator is used in the code
3. ✅ Returns a dict with 'signals' and 'metrics'
4. ✅ All three required metrics are present and finite
5. ✅ Sharpe ratio ≥ 2.0 (excellent risk-adjusted returns)
6. ✅ Max drawdown < 0.25 (25% maximum)
7. ✅ Cumulative returns ≥ 0.8% (meaningful profitable strategy)

## Tips for Success
- **This is a challenging task**: Only well-designed strategies will pass
- **CRITICAL**: Your strategy MUST generate actual trades to have non-zero variance
  - If Sharpe ratio is 0.0, it means your strategy isn't trading enough
  - Aim for at least 5-10 trades across the dataset
- **Handle edge cases carefully**:
  - Remove NaN and inf values: `strategy_returns = strategy_returns[np.isfinite(strategy_returns)]`
  - Use log returns for cumulative calculation to avoid overflow: `np.expm1(np.sum(np.log1p(strategy_returns)))`
  - Always check if arrays are empty before calculations
  - Ensure all final metrics are finite (not NaN or inf)
- **IMPORTANT**: Prevent division by zero in Sharpe ratio calculation:
  - Check if `std(returns) > 0` before dividing
  - Return 0.0 if standard deviation is zero

### Signal Generation Strategies That Work:

**SIMPLE RSI STRATEGY** (Recommended - generates enough trades):
```python
for i in range(26, len(close)):
    if rsi[i] < 45:  # Moderately oversold
        signals[i] = 1
    elif rsi[i] > 55:  # Moderately overbought
        signals[i] = -1
```

**MACD CROSSOVER** (Also works well):
```python
for i in range(26, len(close)):
    if macd[i] > macd_signal[i]:
        signals[i] = 1
    elif macd[i] < macd_signal[i]:
        signals[i] = -1
```

**EMA CROSSOVER** (Simple and effective):
```python
for i in range(26, len(close)):
    if ema_fast[i] > ema_slow[i]:
        signals[i] = 1
    elif ema_fast[i] < ema_slow[i]:
        signals[i] = -1
```

**Combined with Confirmation** (Use if you want better quality):
```python
for i in range(26, len(close)):
    if rsi[i] < 45 and macd[i] > macd_signal[i]:  # Both agree on buy
        signals[i] = 1
    elif rsi[i] > 55 and macd[i] < macd_signal[i]:  # Both agree on sell
        signals[i] = -1
```

### Common Mistakes to Avoid:
- ❌ Requiring 3+ conditions to be true simultaneously (too restrictive)
- ❌ Using extreme RSI thresholds (30/70) - use 40/60 instead
- ❌ Only trading on exact crossovers - allow some flexibility
- ❌ Generating all zeros for signals - this gives Sharpe ratio of 0.0

### Key to Success:
- Generate enough trades (5-10+) to have meaningful variance
- Balance signal quality with signal frequency
- Test that your strategy actually generates non-zero signals
