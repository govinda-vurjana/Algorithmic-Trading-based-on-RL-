# Trading Strategy Implementation Task

Implement a function that generates trading signals using technical analysis on tick data.

## Task Overview
You'll create a trading strategy that:
1. Loads tick-level price data from a CSV file
2. Resamples it to 1-minute OHLC (Open, High, Low, Close) bars
3. Calculates at least ONE technical indicator using TA-Lib
4. Generates trading signals based on the indicator(s)
5. Returns signals and performance metrics

## Function Signature
```python
def predict_trade(data_path: str) -> dict:
    """
    Generate trading signals from tick data.
    
    Args:
        data_path: Path to CSV file with columns: 'day', 'timestamp', 'value'
                   The CSV has a header row.
        
    Returns:
        dict: {
            'signals': np.ndarray of ints (-1, 0, 1),  # sell, hold, buy
            'metrics': {
                'cumulative_returns_final': float,  # Total return (e.g., 0.15 = 15%)
                'sharpe_ratio': float,              # Risk-adjusted return
                'max_drawdown': float,              # Max decline from peak (0-1 range)
            }
        }
    """
```

## Requirements

### 1. Data Processing
- Read the CSV file (has header: 'day', 'timestamp', 'value')
- Resample tick data to 1-minute OHLC bars using `'1min'` frequency
- Handle NaN values appropriately (forward fill or drop)
- The dataset is small (~343 rows), so use all data for both training and testing

### 2. Technical Indicators
**You must use at least ONE technical indicator from TA-Lib in your trading logic.**

Common indicators you can use:
- **RSI** (Relative Strength Index): `talib.RSI(close, timeperiod=14)`
- **MACD** (Moving Average Convergence Divergence): `talib.MACD(close, 12, 26, 9)`
- **EMA** (Exponential Moving Average): `talib.EMA(close, timeperiod=20)`
- **Bollinger Bands**: `talib.BBANDS(close, timeperiod=20)`
- **ATR** (Average True Range): `talib.ATR(high, low, close, timeperiod=14)`
- **Stochastic**: `talib.STOCH(high, low, close, 14, 3, 3)`

**Note**: Do NOT use volume-based indicators (like OBV) as the dataset has no volume data.

### 3. Trading Signals
- Generate signals as integers:
  - `1` = Buy signal
  - `-1` = Sell signal
  - `0` = Hold (no action)
- Signals should be based on your indicator(s)
- The signals array must match the length of your resampled data

### 4. Performance Metrics
Calculate these three required metrics:

- **cumulative_returns_final**: Total return of the strategy
  - Calculate as: `(final_portfolio_value / initial_value) - 1`
  - Must be a finite number between -1.0 and 10.0

- **sharpe_ratio**: Risk-adjusted return
  - Calculate as: `mean(returns) / std(returns) * sqrt(252)`
  - Must be a finite number between -5.0 and 10.0
  - Must be at least 1.0 for a passing strategy (excellent risk-adjusted returns)

- **max_drawdown**: Maximum peak-to-trough decline
  - Calculate as: `max((peak - trough) / peak)` for all peaks
  - Must be between 0.0 and 1.0 (e.g., 0.3 = 30% drawdown)
  - Should be less than 0.5 (50%) for a reasonable strategy

## Example Approach
```python
import pandas as pd
import numpy as np
import talib

def predict_trade(data_path: str) -> dict:
    # 1. Load and resample data
    df = pd.read_csv(data_path, names=['day', 'timestamp', 'value'], header=0)
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df.set_index('timestamp', inplace=True)
    ohlc = df['value'].resample('1min').ohlc().ffill()
    
    # 2. Calculate indicator - choose one or more
    close = ohlc['close'].values
    # Example: rsi = talib.RSI(close, timeperiod=14)
    # Example: macd, signal, hist = talib.MACD(close, 12, 26, 9)
    # Example: ema_fast = talib.EMA(close, 10)
    
    # 3. Generate trading signals based on your indicator
    signals = np.zeros(len(close), dtype=int)
    # TODO: Implement your trading logic here
    # signals[condition] = 1   # Buy
    # signals[condition] = -1  # Sell
    
    # 4. Calculate performance metrics
    returns = np.diff(close) / close[:-1]
    strategy_returns = returns * signals[:-1]
    
    # Cumulative returns
    cumulative_returns = np.prod(1 + strategy_returns) - 1
    
    # Sharpe ratio (with safety check)
    mean_ret = np.mean(strategy_returns)
    std_ret = np.std(strategy_returns)
    sharpe = (mean_ret / std_ret * np.sqrt(252)) if std_ret > 0 else 0.0
    
    # Max drawdown
    cumulative = np.cumprod(1 + strategy_returns)
    running_max = np.maximum.accumulate(cumulative)
    drawdown = (running_max - cumulative) / running_max
    max_dd = np.max(drawdown) if len(drawdown) > 0 else 0.0
    
    return {
        'signals': signals,
        'metrics': {
            'cumulative_returns_final': float(cumulative_returns),
            'sharpe_ratio': float(sharpe),
            'max_drawdown': float(max_dd)
        }
    }
```

## Grading Criteria
Your solution will pass if:
1. ✅ Function `predict_trade` exists and takes one parameter
2. ✅ At least one TA-Lib indicator is used in the code
3. ✅ Returns a dict with 'signals' and 'metrics'
4. ✅ All three required metrics are present and finite
5. ✅ Sharpe ratio ≥ 1.0 (excellent risk-adjusted returns)
6. ✅ Max drawdown < 0.4 (40% maximum)
7. ✅ Cumulative returns > 0 (profitable strategy)

## Tips
- Start simple: use one indicator first, then add more if needed
- Handle NaN values from indicators (they appear at the start)
- **IMPORTANT**: Prevent division by zero in Sharpe ratio calculation:
  - Check if `std(returns) > 0` before dividing
  - Return 0.0 if standard deviation is zero
- **Signal generation**: Use moderate thresholds to ensure trades happen:
  - RSI: Try 40/60 instead of extreme 30/70
  - MACD: Look for crossovers, not just positive/negative
  - EMA: Use crossovers between fast and slow EMAs
- Test your metrics calculations to ensure they're finite (not NaN or inf)
- The dataset is small, so don't over-complicate your strategy
